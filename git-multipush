#!/bin/sh

## version: 1.0

## git multipush: Push a branch to multiple remotes in one command.
## Particularly useful for people hosting on multiple git repo providers all
## at once. e.g., github.com, gitorious.org and repo.or.cz.
##
## Usage: git multipush [-v] [-e] [-n] [-b <branch>] [<remote>...] [-- GIT_OPTIONS]
##
## <branch> is the branch to push -- if none given, pass none to git push
## <remote>... is the list of remotes to push to -- defaults to origin
##
## -v -- print each command as it is run.
## -e -- fail immediately when any push fails. Otherwise, we fail after all
##       pushes with the error code of the last failed push.
## -n -- don't run any commands, just print them.
## -b <branch> -- push <branch> instead of `git symbolic-ref HEAD`
## -d -- debug
##
## GIT_OPTIONS -- passed directly on to git push.
##
## git multipush Copyright 2010 Gavin Beatty <gavinbeatty@gmail.com>.
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or (at
## your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You can find the GNU General Public License at:
##   http://www.gnu.org/licenses/

set -u
set -e

usage() {
    echo "Usage: git multipush [-v] [-e] [-n] [-b <branch>] [<remote>...] [-- GIT_OPTIONS]"
}
die() {
    echo "error: $@" >&2
    exit 1
}

doit() {
    if test -n "$debug" ; then
        sq "$@"
    elif test -n "$verbose" ; then
        echo "$@"
    fi
    if test -z "$dryrun" ; then
        "$@"
    fi
}

sq() {
    git rev-parse --sq-quote "$@"
}

evalit() {
    e=0
    eval "$1" || e=$?
    if test "$e" -ne 0 ; then
        if test -n "$fail" ; then
            exit "$e"
        else
            exit="$e"
        fi
    fi
    return 0
}

main() {
    dryrun=""
    verbose=""
    fail=""
    debug=""
    branch=""
    if ! type "git" 1>/dev/null 2>&1 ; then
        die "Please install git."
    fi
    if ! git rev-parse --git-dir >/dev/null 2>&1 ; then
        die "Not a git repository (or any of the parent directories)"
    fi

    while getopts ":hvenb:d" opt ; do
        case "$opt" in
        h)
            usage
            exit 0
            ;;
        v)
            verbose="true"
            ;;
        e)
            fail="true"
            ;;
        n)
            dryrun="true"
            verbose="true"
            ;;
        b)
            branch="$OPTARG"
            ;;
        d)
            debug="true"
            ;;
        \?)
            die "invalid option: -${OPTARG}"
            ;;
        *)
            die "invalid getopts return: $opt"
            ;;
        esac
    done
    shift "$(expr "$OPTIND" - 1)"
    OPTIND=1

    while test $# -gt 0 ; do
        if test x"$1" = x"--" ; then
            shift
            break
        fi
        remotes="${remotes:- }$(sq "$1")"
        shift
    done
    while test $# -gt 0 ; do
        git_opts="${git_opts:- }$(sq "$1")"
        shift
    done

    eval set -- "${remotes:-}"

    exit=0
    for rem in "$@" ; do
        if test -z "${branch:-}" ; then
            evalit "doit git push${git_opts:-} $(sq "$rem")"
        else
            evalit "doit git push${git_opts:-} $(sq "$rem") $(sq "$branch")"
        fi
    done
    exit "$exit"
}

trap "echo \"caught SIGINT\" ; exit 1 ;" INT
trap "echo \"caught SIGTERM\" ; exit 1 ;" TERM
trap "echo \"caught SIGHUP\" ; exit 1 ;" HUP

main "$@"

